<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统（2）复习</title>
    <link href="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/"/>
    <url>/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>方门！</p><h1>第四章</h1><h2 id="4-2-程序的装入和链接">4.2 程序的装入和链接</h2><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127161120258.png" class="" title="image-20240127161120258"><p>还可以加一个<strong>执行</strong>。</p><p><strong>编译</strong>时形成<strong>虚拟地址</strong>。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127161132366.png" class="" title="image-20240127161132366"><h3 id="4-2-1">4.2.1</h3><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127161529972.png" class="" title="image-20240127161529972"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127161541675.png" class="" title="image-20240127161541675"><h3 id="4-2-2">4.2.2</h3><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127161556142.png" class="" title="image-20240127161556142"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127161604829.png" class="" title="image-20240127161604829"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127161611820.png" class="" title="image-20240127161611820"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127161617917.png" class="" title="image-20240127161617917"><p>运行时动态链接的程序是可重入的程序。</p><h2 id="4-3-连续分配">4.3 连续分配</h2><p>单道和多道都是用的<strong>连续</strong>的内存分配方式。</p><p>单一连续分配。</p><p>分区分配也是连续分配。</p><p>多道程序运行时的<strong>存储保护</strong>：防止多道程序互相干扰。</p><ul><li>只有上邻或下邻：不变</li><li>有上有下：少一项</li><li>无上无下：多一项</li></ul><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127162526779.png" class="" title="image-20240127162526779"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127162604801.png" class="" title="image-20240127162604801"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127162613245.png" class="" title="image-20240127162613245"><p><strong>重点：最佳适应</strong></p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127162700288.png" class="" title="image-20240127162700288"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127162720131.png" class="" title="image-20240127162720131"><p><font color=red><strong>最佳适应一定要掌握</strong></font></p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127162732417.png" class="" title="image-20240127162732417"><p>紧凑的概念了解即可。</p><p>动态重定位和运行时动态链接相关。</p><p>逻辑地址–&gt;物理地址由操作系统实现。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127164014908.png" class="" title="image-20240127164014908"><h2 id="4-4对换">4.4对换</h2><p>了解即可。</p><h2 id="4-5分页">4.5分页</h2><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127164357653.png" class="" title="image-20240127164357653"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127164403706.png" class="" title="image-20240127164403706"><p>图中页大小为$2<sup>{12}$位，页数量为$2</sup>{20}$。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127164410478.png" class="" title="image-20240127164410478"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127164421473.png" class="" title="image-20240127164421473"><p>快表的目的：缩短访问内存的时间，加快访问速度。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127164738914.png" class="" title="image-20240127164738914"><h3 id="4-5-4两级或多级页表">4.5.4两级或多级页表</h3><p><strong>目的</strong>：避免页表使用连续的内存空间存放（因为找不到足够大的连续内存空间用于存放页表）。</p><p>会增加访问时间，无法避免缺页中断问题。</p><p>外层页号也叫”页目录号“和”页表项“。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127165201109.png" class="" title="image-20240127165201109"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240127165214242.png" class="" title="image-20240127165214242">:watch:周一第二节课`23:29`<h3 id="4-5-5-反置页表">4.5.5 反置页表</h3><p>按内存空间建立页表。（了解概念）</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128001527148.png" class="" title="image-20240128001527148"><h2 id="4-6分段">4.6分段</h2><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128001740664.png" class="" title="image-20240128001740664"><h1>第五章</h1><p>注意<strong>请求分页的页表机制</strong>、<strong>缺页中断的机制</strong>、<strong>缺页中断后的处理方式</strong> 、<strong>抖动</strong>、<strong>工作集</strong>。</p><h2 id="5-2-请求分页">5.2 请求分页</h2><p>与请求分页对应的是预调页机制，预调页机制不属于请求分页系统，工作集属于预调页。</p><p>请求页表一定有<strong>状态位</strong>、<strong>访问字段</strong>、<strong>修改位</strong>。</p><p>外存地址看情况。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128002530292.png" class="" title="image-20240128002530292"><p>缺页中断产生时指令未执行完，处理完缺页中断后重新执行该指令。</p><p><strong>缺页中断与其他中断的区别</strong>：</p><ol><li>缺页中断在指令执行期间产生和处理。</li><li><strong>缺页中断处理完后返回到产生缺页中断的指令，并重新执行该指令</strong>。</li></ol><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128002729984.png" class="" title="image-20240128002729984"><p>产生缺页中断信号的硬件为 MMU（内存管理单元）。</p><h2 id="5-3-页面置换算法">5.3 页面置换算法</h2><p>最佳置换只是理论的算法，实际上不用。</p><p>实际上用的是FIFO、LRU、LFU、clock置换。</p><h2 id="5-4-抖动和工作集">5.4 抖动和工作集</h2><p>两种调页策略：请求分页和预调页。</p><p>工作集用的是预调页策略。</p><p><strong>产生抖动的原因：</strong></p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128004809179.png" class="" title="image-20240128004809179"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128004850130.png" class="" title="image-20240128004850130"><p>要知道Denning这个人。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128005126874.png" class="" title="image-20240128005126874"><h1>第六章 输入输出系统</h1><h3 id="6-1-2">6.1.2</h3><p><strong>I/O软件的层次结构</strong>：（强调了要记下来）</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128005653917.png" class="" title="image-20240128005653917"><h3 id="6-5">6.5</h3><p>驱动程序这里提了好久，但是一直在讲上周做pre的同学balabala咋样。</p><p>要知道扇区。</p><p>I/O设备分为<strong>字符设备</strong>和<strong>块设备</strong>。</p><p>块设备一般指磁盘。</p><p>linux的文件系统是在块设备上实现的。</p><p>⌚<code>24:12</code></p><p>通常通过逻辑设备来访问物理设备。</p><h2 id="6-8">6.8</h2><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128101646516.png" class="" title="image-20240128101646516"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128101703391.png" class="" title="image-20240128101703391"><p>最短寻道时间优先SSTF和扫描算法SCAN要回算。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128101850464.png" class="" title="image-20240128101850464"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128101856236.png" class="" title="image-20240128101856236"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128101907574.png" class="" title="image-20240128101907574"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128101915822.png" class="" title="image-20240128101915822"><p>先来先服务FCFS不会导致磁臂粘着。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128101952421.png" class="" title="image-20240128101952421"><h1>第七章 文件管理</h1><h2 id="7-2">7.2</h2><p>现在大部分文件都是无结构文件。</p><p>好处：对文件的解释是由应用程序实现。</p><p>无逻辑结构，但是有树形的组织结构，有物理结构。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128102209859.png" class="" title="image-20240128102209859"><h2 id="7-3">7.3</h2><p>文件控制块包含的信息要记下来。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128102518153.png" class="" title="image-20240128102518153"><h3 id="7-3-2-简单的文件目录">7.3.2 简单的文件目录</h3><p>单级目录特点：加快查询速度。⌚<code>11:00</code>（但是很奇怪，书上说单级目录的缺点是查找速度慢）</p><h1>第八章 磁盘存储器的管理</h1><h2 id="8-1">8.1</h2><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128111544106.png" class="" title="image-20240128111544106"><p>增量式索引</p><p>这里有计算，给一个磁盘地址或块号，问应该用几级索引。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128111645034.png" class="" title="image-20240128111645034"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128111651936.png" class="" title="image-20240128111651936"><h2 id="8-2">8.2</h2><p>位示图有计算</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128112208905.png" class="" title="image-20240128112208905"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128112220156.png" class="" title="image-20240128112220156"><p>成组链接法没有计算，但是要会解释过程（特别是空闲块的分配和回收）。</p><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128112244342.png" class="" title="image-20240128112244342"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128112305392.png" class="" title="image-20240128112305392"><img src="/2024/01/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20240128112311016.png" class="" title="image-20240128112311016"><h1>实验</h1><p>文件相关调用：<code>open,link,dup,mmap,lseek</code>的意思。</p><p>选择、填空、判断、简答、计算。</p>]]></content>
    
    
    <categories>
      
      <category>考试周</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考试周复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统（1）复习</title>
    <link href="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>第一章</h1><p><code>35:39</code></p><h3 id="1-1-1-操作系统的目标">1.1.1 操作系统的目标</h3><p>4个目标：<strong>方便性</strong>和<strong>有效性</strong>是设计OS时<strong>最重要</strong>的两个目标。</p><ol><li><p><strong>方便性</strong></p><ul><li>无OS时需要编写机器码，而OS可以让用户使用高级语言。</li></ul></li><li><p><strong>有效性</strong></p><ul><li><p>第一层含义：提高系统资源的利用率</p></li><li><p>第二层含义：提高系统的吞吐量</p></li></ul></li><li><p>可扩充性</p><ul><li>可扩充性的好坏与OS的结构有紧密的联系：无结构 =&gt; 模块化 =&gt; 层次化 =&gt; 微内核</li></ul></li><li><p>开放性</p></li></ol><h3 id="1-1-2-操作系统的作用">1.1.2 操作系统的作用</h3><ol><li>OS作为用户和计算机硬件系统之间的接口<ul><li>用户可以用三种方式使用系统：<ul><li>命令</li><li>系统调用</li><li>图标——窗口</li></ul></li></ul></li><li>OS作为系统资源的管理者<ul><li>系统资源有4种：处理机、存储器、I/O设备、文件（数据和程序）</li><li>OS的主要功能也是对这4类资源进行有效的管理：<ul><li>处理机管理：用于分配和控制处理机</li><li>存储器管理：主要负责内存的分配与回收</li><li>I/O设备管理：负责I/O设备的分配（回收）与操纵</li><li>文件管理：实现对文件的存取、共享和保护。</li></ul></li></ul></li><li>OS实现了对计算机资源的抽象<ul><li>扩充机器 或 虚机器：它向用户提供了一个对硬件操作的抽象模型。用户无需了解物理接口实现的细节。（第一个层次的抽象）</li><li>又可在第一层软件（I/O管理软件）上再覆盖一层用于文件管理的软件，由它实现对文件操作的细节，并向上层提供一组对文件进行存取操作的数据结构及命令。（第二个层次的抽象）</li><li>随着抽象层次的提高，抽象接口所提供的功能就越强，用户使用起来也越方便。</li></ul></li></ol><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231105192718669.png" class="" title="image-20231105192718669"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231105192802898.png" class="" title="image-20231105192802898"><h3 id="1-2-单道和多道">1.2 单道和多道</h3><h3 id="1-2-2-单道批处理系统">1.2.2 单道批处理系统</h3><p>为了提高计算机利用率，应尽量保持系统的连续运行（脱机输入/输出Off-Line I/O方式）：</p><ul><li>减少CPU空闲时间</li><li>提高I/O速度</li></ul><p>单道批处理系统特点：</p><ul><li>一次一个作业</li><li>顺序执行</li><li>不存在作业和进程的切换</li><li>系统配上<strong>监督程序</strong>（monitor）控制作业的连续处理</li></ul><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231105193859456.png" class="" title="image-20231105193859456"><p><strong>主要缺点</strong>：系统资源得不到充分利用</p><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231105194122229.png" class="" title="image-20231105194122229"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231105194213951.png" class="" title="image-20231105194213951"><h3 id="1-2-3-多道批处理系统">1.2.3 多道批处理系统</h3><ul><li>没有交互</li><li>有作业调度问题</li><li>目的是：进一步提高资源的利用率和系统吞吐量</li><li>后备队列：用户提交的作业先存放在外存上，并排成一个队列。</li><li>共享CPU和系统中的各种资源</li></ul><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231105194923883.png" class="" title="image-20231105194923883"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231105194937063.png" class="" title="image-20231105194937063"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231105195258223.png" class="" title="image-20231105195258223"><h3 id="1-2-6操作系统的发展">1.2.6操作系统的发展</h3><p>unix和linux是多用户多任务操作系统。</p><p>unix不是微内核。</p><p>linux是unix的一个重要变种，最初由芬兰学生Linus Torvalds针对Intel80386开发。</p><h3 id="1-5-4-微内核">1.5.4 微内核</h3><p>结构，3个基本功能，优点</p><p>基于客户/服务器模式的微内核结构，将操作系统划分为两大部分：微内核和多个服务器。</p><p><strong>微内核结构：</strong></p><ol><li>足够小的内核<ul><li>在微内核操作系统中，内核是指：精心设计的、能实现现代OS最基本核心功能的小型内核</li><li>微内核并非一个完整的OS，而只是将操作系统中最基本的部分放入微内核 =&gt; 所以微内核很小：<ul><li>①与硬件紧密相关的部分</li><li>②一些较基本的功能</li><li>③客户和服务器之间的通信</li></ul></li></ul></li><li>基于客户/服务器模式</li><li>应用“机制与策略分离”原理<ul><li>机制：实现某一功能的具体执行结构</li><li>策略：在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标</li><li>传统OS：机制位于OS的内核的较低层，策略位于OS的内核的较高层</li><li>微内核：通常将机制放在OS的微内核中 =&gt; 所以微内核很小</li></ul></li><li>采用面向对象技术</li></ol><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106150702381.png" class="" title="image-20231106150702381"><p><strong>微内核的基本功能</strong>：</p><ol><li>进程（线程）管理</li><li>低级存储器管理</li><li>中断和陷入处理</li></ol><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106183856487.png" class="" title="image-20231106183856487"><p><strong>微内核操作系统的优点</strong>：</p><ol><li>提高了系统的可扩展性<ul><li>微内核OS的许多功能是由相对独立的服务器软件来实现的</li></ul></li><li>增强了可靠性<ul><li>一方面是由于微内核是通过精心设计和严格测试的</li><li>另一方面，它提供了规范而精简的应用程序接口（API）</li><li>此外，所有服务器都是运行在<strong>用户态</strong>，服务器于服务器之间采用的是<strong>消息传递通信机制</strong>，当某个服务器出现错误时，不会影响内核和其他服务器</li></ul></li><li>可移植性强<ul><li>所有于特定CPU和I/O设备硬件有关的代码，均放在内核和内核下面的硬件隐藏层中，而操作系统其他绝大部分——各种服务器，均于硬件平台无关。</li></ul></li><li>提供了对分布式系统的支持<ul><li>客户和服务器之间、服务器和服务器之间的通信采用<strong>消息传递机制</strong>，只要在分布式系统中赋予所有进程和服务器唯一的标识符，再配置一张系统映射表，就可以实现分布式系统。</li></ul></li><li>融合了面向对象技术</li></ol><p><strong>微内核操作系统存在的问题</strong>：</p><ul><li>最主要的问题是，较之早期的操作系统，微内核操作系统的运行效率有所降低。</li></ul><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106185151385.png" class="" title="image-20231106185151385"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106185159371.png" class="" title="image-20231106185159371"><h1>第二章 进程的描述与控制</h1><p>第十周第一节课<code>41:40</code></p><p>修正：前驱图不用管<code>41:12</code></p><h3 id="2-2-进程">2.2 进程</h3><h3 id="2-2-1-进程的定义和特征">2.2.1 进程的定义和特征</h3><p>要和线程比较</p><ul><li>程序段、相关的数据段和PCB三部分构成了<strong>进程实体（进程映像）</strong>。</li></ul><p><strong>进程的定义</strong>：</p><ol><li>进程是程序的一次执行</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li></ol><ul><li>在引入了进程实体的概念后，我们可以把传统OS中的进程定义为：“进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。”</li></ul><p><strong>进程的特征</strong>：</p><p>进程和程序是2个截然不同的概念，除了进程具有程序所没有的PCB外，还具有下面特征：</p><ol><li>动态性（最基本的特征）<ul><li>进程的<strong>实质</strong>是进程实体的执行过程</li><li>动态性还表现在：“它由创建而生，由调度而执行，由撤销而消亡。” =&gt; 所以进程实体有一定的生命期，而程序只是一组有序指令的集合，并存放在某种介质上，其本身不具有活动哦的含义，因而是静态的。</li></ul></li><li>并发性<ul><li>是指多个进程实体同时存在于内存中，且能在<strong>一段时间内</strong>同时运行。 =&gt; 也是引入进程的目的</li><li>并发性是进程的另一重要特征，也是OS的重要特征</li><li>程序（没有建立PCB）是不能参与并发执行的</li></ul></li><li>独立性<ul><li>进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位</li><li>凡未建立PCB的程序都不能作为一个独立的单位参与运行</li></ul></li><li>异步性<ul><li>异步性导致传统程序若参与并发执行，会产生其结果的不可在现行。=&gt; 所以引入进程的概念，并配置进程同步机制。</li></ul></li></ol><h3 id="2-2-2-3种状态">2.2.2 3种状态</h3><p>什么是就绪、执行、阻塞状态</p><p>三者如何转换：为什么+何时</p><p>第十周第二节课<code>00:00</code></p><p>注意平板上的笔记。</p><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106192404344.png" class="" title="image-20231106192404344"><p>状态转换<strong>最常见</strong>的原因是：时间片结束（也有其他原因）</p><p>一个程序的时间片结束后不会唤醒其他进程（不像信号量，信号量会用PV操作唤醒其他进程）</p><p>程序唤醒后要就绪才能执行，唤醒后并不能马上执行。</p><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106193451123.png" class="" title="image-20231106193451123"><p>创建状态、终止状态和挂起操作老师好像没提到？还是看看书吧。</p><h3 id="2-3-3和2-3-4-影响进程终止、阻塞和唤醒的事件">2.3.3和2.3.4 影响进程终止、阻塞和唤醒的事件</h3><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106194830840.png" class="" title="image-20231106194830840"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106194923746.png" class="" title="image-20231106194923746"><h3 id="2-3-2与进程创建相关的调用及其含义-（实验课上讲过）">2.3.2与进程创建相关的调用及其含义 （实验课上讲过）</h3><p>wait()</p><p>sleep()</p><h3 id="2-4-进程同步">2.4 进程同步</h3><p>遵守的4个规则</p><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106195457474.png" class="" title="image-20231106195457474"><h3 id="2-4-1-临界区的概念">2.4.1 临界区的概念</h3><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106195436959.png" class="" title="image-20231106195436959"><h3 id="2-4-3-信号量机制">2.4.3 信号量机制</h3><p>同步主要看信号量机制</p><p>原子操作：wait(),signal()（也被成为PV操作）</p><p>信号量机制是低级的通信原理</p><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106200834120.png" class="" title="image-20231106200834120"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106201022269.png" class="" title="image-20231106201022269"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106201034405.png" class="" title="image-20231106201034405"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106201044489.png" class="" title="image-20231106201044489"><p>AND型信号量了解即可。</p><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106202152853.png" class="" title="image-20231106202152853"><h3 id="2-5-1-生产者—消费者问题">2.5.1 生产者—消费者问题</h3><h3 id="2-6-管道">2.6 管道</h3><p>管道是一种重要的进程通信方式，是一种特殊类型的文件。</p><p>管道是指：用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。</p><p>管道机制必须提供三方面的协调能力：①互斥；②同步；③确定对方存在。</p><h3 id="2-6-2-信箱">2.6.2 信箱</h3><p>信箱是一种间接的通信方式。</p><h3 id="2-7-线程">2.7 线程</h3><p>课本P82-83：线程和进程的比较</p><p>记录点<code>[24:55]</code></p><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106203111715.png" class="" title="image-20231106203111715"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106203121733.png" class="" title="image-20231106203121733"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106203131567.png" class="" title="image-20231106203131567"><h3 id="2-8-线程的实现">2.8 线程的实现</h3><p>只看前两种，并了解它们的区别，比较：调度方面、并发性、拥有的资源、独立性、系统开销。</p><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106203334832.png" class="" title="image-20231106203334832"><img src="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%881%EF%BC%89%E5%A4%8D%E4%B9%A0/image-20231106203347720.png" class="" title="image-20231106203347720"><h1>第三章 处理机调度与死锁</h1><h3 id="3-1-2-周转时间的概念和计算">3.1.2  周转时间的概念和计算</h3><h3 id="3-2-3-短作业优先调度算法">3.2.3 短作业优先调度算法</h3><h3 id="3-2-4-高响应比优先调度算法">3.2 4 高响应比优先调度算法</h3><p><code>40:00</code>在讲例题</p><h3 id="3-3-2-轮转调度算法">3.3.2 轮转调度算法</h3><h3 id="3-3-3-优先级调度算法">3.3.3 优先级调度算法</h3><h3 id="3-3-5-多级反馈队列调度算法">3.3.5 多级反馈队列调度算法</h3><p>把机制记下来，把优缺点分析清楚</p><p>处理机并不是任何时候都在运行状态。</p><h3 id="3-5-死锁">3.5 死锁</h3><p>主要原因归纳为①竞争资源；②进程推进顺序不当。</p><h3 id="3-5-3死锁的定义、必要条件和处理方法">3.5.3死锁的定义、必要条件和处理方法</h3><h3 id="3-6-预防死锁">3.6 预防死锁</h3><p>对资源类型排序=&gt;破坏“循环等待”条件。</p><h3 id="3-7-避免死锁">3.7 避免死锁</h3><p>银行家算法的例子</p><h3 id="3-8-2-死锁的解除">3.8.2 死锁的解除</h3><h1>第九章 操作系统接口</h1><h3 id="9-4-系统调用">9.4 系统调用</h3><p>系统调用基于中断机制</p><p>判断、选择、填空、简答、综合。</p><p>综合类：银行家算法，信号量，作业调度，短作业优先，高响应比优先，以及给一个程序，让你判断程序的意思（实验课内容）。</p>]]></content>
    
    
    <categories>
      
      <category>考试周</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考试周复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板</title>
    <link href="/2023/06/15/%E6%A8%A1%E6%9D%BF/"/>
    <url>/2023/06/15/%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1>数据结构</h1><h2 id="线段树1">线段树1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a[maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tree[<span class="hljs-number">4</span>*maxn];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tag[<span class="hljs-number">4</span>*maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        tree[p]=a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>,l,mid);<br>    <span class="hljs-built_in">build</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br>    tree[p]=tree[p*<span class="hljs-number">2</span>]+tree[p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spread</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(tag[p])&#123;<br>        <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> lson=p*<span class="hljs-number">2</span>,rson=lson+<span class="hljs-number">1</span>;<br>        tag[lson]+=tag[p];<br>        tree[lson]+=tag[p]*(mid-l+<span class="hljs-number">1</span>);<br>        tag[rson]+=tag[p];<br>        tree[rson]+=tag[p]*(r-mid);<br>        tag[p]=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//注意这里的cl,cr为查询的区间，l和r为节点的区间</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> cl,<span class="hljs-type">int</span> cr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-comment">// cout&lt;&lt;&quot;dbg:&quot;&lt;&lt;cl&lt;&lt;&quot; &quot;&lt;&lt;cr&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;tree[p]&lt;&lt;endl;</span><br>    <span class="hljs-keyword">if</span>(cl&lt;=l&amp;&amp;cr&gt;=r)<br>        <span class="hljs-keyword">return</span> tree[p];<br>    <span class="hljs-built_in">spread</span>(p,l,r);<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(cl&lt;=mid) res+=<span class="hljs-built_in">ask</span>(p*<span class="hljs-number">2</span>,cl,cr,l,mid);<br>    <span class="hljs-keyword">if</span>(cr&gt;mid) res+=<span class="hljs-built_in">ask</span>(p*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,cl,cr,mid+<span class="hljs-number">1</span>,r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> d,<span class="hljs-type">int</span> cl,<span class="hljs-type">int</span> cr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(cl&lt;=l&amp;&amp;cr&gt;=r)&#123;<br>        tag[p]+=d;<br>        tree[p]+=d*(r-l+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">spread</span>(p,l,r);<br>    <span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> lson=p*<span class="hljs-number">2</span>,rson=lson+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(cl&lt;=mid) <span class="hljs-built_in">change</span>(lson,d,cl,cr,l,mid);<br>    <span class="hljs-keyword">if</span>(cr&gt;mid) <span class="hljs-built_in">change</span>(rson,d,cl,cr,mid+<span class="hljs-number">1</span>,r);<br>    tree[p]=tree[lson]+tree[rson];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> opt,x,y,z;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;opt);<br>        <span class="hljs-keyword">if</span>(opt==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;z);<br>            <span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>,z,x,y,<span class="hljs-number">1</span>,n);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>,&amp;x,&amp;y);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,<span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>,x,y,<span class="hljs-number">1</span>,n));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 1 7 6 2 3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/06/07/%E5%8D%B7%E7%A7%AF/"/>
    <url>/2023/06/07/%E5%8D%B7%E7%A7%AF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构2 PTA的一点点知识点（少）</title>
    <link href="/2023/05/30/dataStructure2PTA/"/>
    <url>/2023/05/30/dataStructure2PTA/</url>
    
    <content type="html"><![CDATA[<h1>2</h1><ul><li><p>2-13 G1是G的生成树，则G1不是G的连通分量，G1是G的极小连通子图</p></li><li><p>2-14 一个有向图有n个顶点，则每个顶点的度可能的最大值是 $ 2(n-1) $，此处不考虑重边和自环。</p></li></ul><h1>4</h1><ul><li><p>1-6 若一个有向图的邻接矩阵对角线以下元素均为零，则该图的拓扑有序序列必定存在。</p><p>这是对的，因为上三角矩阵意味着只有编号小的点指向编号大的点，则一定不存在回路。</p><p>任何一个无环的有向图一定有拓扑序列，有环的有向图则没有拓扑序列。</p></li></ul><h1>5</h1><p>2-2 选c，因为弧（P210）的定义为：箭头的起始端为弧尾，结束端为弧头。</p><h1>6</h1><ul><li>1-8 当向二叉搜索树中插入一个结点，则该结点一定成为叶子结点。</li></ul><p>这是 对  的。注意是二叉搜索树，只插入到相匹配的叶子上。</p><ul><li>1-10 对大小均为n的有序表和无序表分别进行顺序查找，在等概率查找的情况下，对于查找成功，它们的平均查找长度是相同的，而对于查找失败，它们的平均查找长度是不同的。</li></ul><p>这是 对 的。查找失败指的是表中没有这个元素，而有序表因为有序，对p，当有a&lt;p&lt;b时即可停止。无序表就要查完整个表才行。</p><ul><li><p>2-6 对22个记录的有序表作折半查找，当查找失败时，至少需要比较（ ）次关键字。</p><p>填4 。至少4次，至多5次。不是满二叉树。</p></li><li><p>2-17 在长度为32的有序表中进行二分查找时，所需进行的关键字比较次数最多为( )</p></li></ul><p>答案是6. 注意二叉树的节点数，31的高度为5，32就是6了。</p><p>$2^k-1=n$ ,k为高度。</p><h1>chapter7 图</h1><ul><li><p>1-8 <strong>十字链表</strong>是<strong>有向图</strong>的一种存储结构</p><p>​       <strong>邻接多重表</strong>是<strong>无向图</strong>的一种存储结构</p></li><li><p>1-33 <strong>连通分量</strong>是<strong>无向图</strong>中的极大连通子图。</p><p>​        <strong>强连通分量</strong>是<strong>有向图</strong>中的极大连通子图。</p><p>​         <strong>连通图</strong>和<strong>连通分量</strong>都是<strong>无向图</strong>的概念。</p><p>​          <strong>强连通图</strong>和<strong>强连通分量</strong>都是<strong>有向图</strong>的概念</p></li><li><blockquote><p>2-6例题：G是一个非连通无向图，共有28条边，则该图至少有（）个顶点。</p></blockquote><p>考虑到<strong>非连通图</strong>，应该最终答案加1，故答案为9</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>考试周</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据机构, 考试周复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first page</title>
    <link href="/2023/05/29/firstPage/"/>
    <url>/2023/05/29/firstPage/</url>
    
    <content type="html"><![CDATA[<h3 id="行内公式测试：-E-mc-2">行内公式测试： $E=mc^2$</h3><h3 id="行间公式测试">行间公式测试:</h3><p>$$\sum_\limits{i=1}^{n}i=\frac{n(n+1)}{2} $$</p><h3 id="代码测试：">代码测试：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iosteam&gt;</span></span><br>usign <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表格测试：">表格测试：</h3><table><thead><tr><th>序号</th><th>日期</th><th>文章标题</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="分割线测试：">分割线测试：</h3><hr><h3 id="颜色测试：-font-color-red-绿色-font">颜色测试：<font color=red>绿色</font></h3><h3 id="emoji测试-😂">emoji测试 😂</h3><h3 id="链接测试：如何在markdown使用emoji">链接测试：<a href="https://gist.github.com/rxaviers/7360908" title="emoji">如何在markdown使用emoji</a></h3><p><a href="https://github-emoji-picker.rickstaa.dev/" title="点击就复制到剪切板">emoji工具</a> 😀</p><h3 id="图片测试：">图片测试：</h3><img src="/2023/05/29/firstPage/yourName.jpg" class="" title="yourName"><p>测试B站视频（当前为评论区第三版）：</p><p>教程参考：<a href="https://luhuadong.com/hexo/hexo-video.html">HEXO插入B站视频教程</a> -----（感觉这篇教程里的主题很好看）</p><iframe src="//player.bilibili.com/player.html?aid=655571722&bvid=BV1Ea4y157HT&cid=1127209236&page=1&high_quality=1" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>]]></content>
    
    
    <categories>
      
      <category>你好啊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开始的开始</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/05/29/hello-world/"/>
    <url>/2023/05/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
